//
//  WeatherInteractor.swift
//  DarkSkyWeather
//
//  Created by rowkaxl on 07/08/2019.
//  Copyright (c) 2019 rowkaxl. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import RxSwift
import RxCocoa
import MapKit
import Contacts

protocol WeatherBusinessLogic {
    func doRecentData()
    func doDarkSkyWeather(request: Weather.Info.Request)
    func doSaveLocation(mkMapItem: MKMapItem)
}

protocol WeatherDataStore {
    var currentPlacemark: PublishRelay<MKPlacemark> { get set }
    var recentPlace: Place? { get set }
}

class WeatherInteractor: WeatherBusinessLogic, WeatherDataStore, PlaceProtocol, MapKitProtocol {
    
    var presenter: WeatherPresentationLogic?
    var worker = WeatherWorker()
    var currentPlacemark = PublishRelay<MKPlacemark>()
    var recentPlace: Place? = nil
    
    let disposeBag = DisposeBag()
    
    let locationManager = LocationManager()
    
    func doRecentData() {
        
        PlaceManager.shared.placeDelegate = self
        PlaceManager.shared.getSearchPlace()
    }
    
    // 날씨 정보 요청
    func doDarkSkyWeather(request: Weather.Info.Request) {
    
        if let apiKey = Bundle.main.infoDictionary?["DarkSkySecretKey"] as? String {
            worker.requestDarkSkyWeather(apiKey: apiKey, coordinate: request.placeMark.coordinate)
                .filter{$0.code == .code200}
                .subscribe(onSuccess: { (code, json) in
                    
                    let model = DarkSkyWeatherModel(data: json)
                    
                    print(request.keyword)
                    print(request.placeMark.locality ?? "")
                    print(model.latitude)
                    print(model.longitude)
                    
                    let response = Weather.Info.Response(weatherModel: model, keyword: request.keyword)
                    self.presenter?.presentDarkSkyWeather(response: response)
                })
                .disposed(by: disposeBag)
        }
    }
    
    // 최근 검색정보저장
    func doSaveLocation(mkMapItem: MKMapItem) {
        worker.requestSaveLocation(mkMapItem: mkMapItem)
            .subscribe(onSuccess: { (value) in
                if !value {
                    print("Failed saving")
                }
            })
            .disposed(by: disposeBag)
            
    }
}

extension WeatherInteractor {
    
    func resultPlace(place: Place?) {
        
        if let place = place {
            // 저장되어 있는 장소로 정보 날씨 요청
            
            let request = Weather.Info.Request(placeMark: MKPlacemark(coordinate: CLLocationCoordinate2D(latitude: place.latitude, longitude: place.longitude),
                                                                      addressDictionary: [CNPostalAddressCityKey:place.locality ?? ""]),
                                               keyword: place.keyword ?? "")
            
            self.doDarkSkyWeather(request: request)
            self.recentPlace = place
        }
        self.getCurrentLocation()
    }
}

extension WeatherInteractor {
    
    // 현재 위치정보 요청
    func getCurrentLocation() {
        locationManager.getCurrentLocation()
        locationManager.mapKitDelegate = self
    }
    
    // 현재위치 정보
    func updateLocation(placeMark: MKPlacemark) {
        self.currentPlacemark.accept(placeMark)
    }
}
